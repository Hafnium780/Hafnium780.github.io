<!DOCTYPE html>
<html>
	<head>
		<title>hi</title>
		<meta
			name="google-site-verification"
			content="nwiDYewgmTc1xCpZ5-JJ0Zt6LDAwp5bOurIgnaaJAAM"
		/>
		<style>
			* {
				margin: 0px;
				padding: 0px;
			}

			body {
				background-color: black;
			}

			#main {
				position: fixed;
				height: 130vh;
				width: 140vw;
				left: 0px;
				top: 0px;
				translate: 0px 0px;
				background: black;
			}

			.node {
				background-color: lightgray;
				color: black;
				text-decoration: none;
				border: 2px solid black;
				position: absolute;
				border-radius: 50%;
				z-index: 10;
				font-family: "Trebuchet MS", "Lucida Sans Unicode", "Lucida Grande",
					"Lucida Sans", Arial, sans-serif;
				display: flex;
				flex-direction: column;
				justify-content: center;
				align-items: center;
				font-size: 15px;
				text-align: center;
			}

			a.node {
				background-color: #aaaaaa;
			}

			a.filled.node {
				background-color: #aa3333;
			}

			.filled.node {
				background-color: #dd5555;
				scale: 110%;
				box-shadow: 0px 0px 10px 2px white;
				transition: background-color ease 100ms, scale ease 100ms,
					box-shadow ease 100ms;
			}

			.edge {
				background-color: lightgray;
				border: 2px solid gray;
				position: absolute;
				z-index: 0;
				overflow: hidden;
			}

			.filled.edge {
				background-color: #dd5555;
				scale: 105%;
				box-shadow: 0px 0px 1px 1px white;
				transition: scale ease 100ms, box-shadow ease 100ms;
			}

			.anim {
				background-color: red;
				translate: -100% 0px;
			}
		</style>
	</head>

	<body>
		<!--
      <layer of tree>
        name|description
        <layer of tree>
        ...
      </layer of tree>
    -->
		<div id="main"></div>
		<div id="tree" style="display: none">
			Projects|
			<div>
				Mini Web Demos|
				<div>
					p5.js|
					<div>
						Interactive|
						<a href="golf"> golf| </a>
						<a href="circle"> circle| </a>
						<a href="gravity"> gravity| </a>
						<a href="minesweeper3d"> 3d minesweeper| </a>
						<a href="raycasting"> raycasting| </a>
					</div>
					<a href="car"> car| </a>
					<a href="perlin"> perlin| </a>
				</div>
			</div>
			<div>
				Google Extensions|
				<a
					href="https://github.com/Hafnium780/Hafnium780.github.io/tree/main/bomb-party"
				>
					bomb party|
				</a>
				<a
					href="https://github.com/Hafnium780/Hafnium780.github.io/tree/main/schoology-grades"
				>
					schoology grades|
				</a>
			</div>
			<div>
				Large Projects|
				<div>
					React.js|
					<a href="graph-algorithms"> graph algorithms| </a>
				</div>
				<div>
					Node.js|
					<a href="https://multiplayer-platformer.glitch.me/">
						multiplayer platformer|
					</a>
				</div>
			</div>
		</div>
		<script defer>
			// Defined constants
			const angleFromBottom = Math.PI / 12; // Angle between either side of tree and bottom
			const sideMargins = 50;
			const nodeRadius = 50;
			const edgeWidth = 20;
			const animationSpeed = 70;

			const main = document.getElementById("main");

			// Calculated constants
			const leftTreeBound = Math.PI - angleFromBottom; // Angle between left side of tree and bottom
			const rightTreeBound = angleFromBottom; // Angle between right side of tree and bottom
			const treeAngle = Math.PI - 2 * angleFromBottom; // Angle available to use for tree
			const treeRadius =
				Math.min(main.offsetWidth / 2, main.offsetHeight) -
				sideMargins * 2 -
				nodeRadius / 2; // Radius of tree
			console.log(main.offsetWidth / 2, main.offsetHeight);

			const nodesToEdge = new Map();
			const allNodes = [];

			const crawl = (node, depth = 0) => {
				// Convert html nodes to tree nodes
				const text = node.firstChild.nodeValue.trim().split("|");
				const tree = {
					name: text[0], // name of node
					description: text[1], // description of node
					depth: depth, // depth of node from root
					maxDepth: depth, // maximum depth of subtree
					size: 1, // size of subtree
					children: [], // subtree
					leafCount: 0, // number of leaf nodes in subtree
					parent: null, // parent
					isLink: node.nodeName === "A", // is it a link
					href: node.href, // link
				};
				allNodes.push(tree);
				for (const child of node.children) {
					const childTree = crawl(child, depth + 1);
					childTree.parent = tree;
					tree.children.push(childTree);
					tree.size += childTree.size;
					tree.leafCount += childTree.leafCount;
					tree.maxDepth = Math.max(tree.maxDepth, childTree.maxDepth);
				}

				if (!node.children.length) tree.leafCount = 1;

				return tree;
			};

			const root = document.getElementById("tree");
			const tree = crawl(root);
			root.remove();

			const nodeAngle = treeAngle / tree.leafCount;

			// Each node takes up (radius left over/(depth of subtree)) space radially, and (nodeAngle*leaf) space tangentially
			// Each path
			//   Goes through x nodes
			//   -> radius is not treeRadius/x, but
			//         x-- --x-- --x--
			//          r/2  r     r
			//       treeRadius/(x-1/2)

			const radialSpace = (node, radiusLeft) => {
				return radiusLeft / (node.maxDepth - node.depth + 0.5);
			};

			const angleSpace = (node) => {
				return nodeAngle * node.leafCount;
			};

			const polarToScreen = (r, a) => {
				// Polar coordinates to screen (board) coordinates
				// Top left = 0, 0
				// pos y goes down
				return {
					x: Math.cos(a) * r + main.offsetWidth / 2,
					y: main.offsetHeight - sideMargins - Math.sin(a) * r,
				};
			};

			const moveDiv = (div, x, y, width, height) => {
				// Place center of div at x, y
				div.style.left = Math.floor(x - width / 2) + "px";
				div.style.top = Math.floor(y - height / 2) + "px";
				// div.style.left = Math.floor(x) + "px";
				// div.style.top = Math.floor(y) + "px";
			};

			const drawEdge = (x1, y1, x2, y2) => {
				// Draw edge from x1, y1 to x2, y2
				const length = Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));
				const edge = document.createElement("div");
				edge.classList.add("edge");
				edge.style.height = edgeWidth + "px";
				edge.style.width = length + "px";
				edge.style.rotate = Math.atan2(y2 - y1, x2 - x1) + "rad";
				moveDiv(edge, (x1 + x2) / 2, (y1 + y2) / 2, length, edgeWidth);
				const anim = document.createElement("div");
				anim.classList.add("anim");
				anim.style.height = edgeWidth + "px";
				anim.style.width = length + "px";
				main.appendChild(edge);
				edge.appendChild(anim);
				return { edge: edge, anim: anim };
			};

			const drawTree = (node, leftBound, rightBound, radiusLeft) => {
				nodesToEdge.set(node, new Map());
				const radial = radialSpace(node, radiusLeft);
				const angle = angleSpace(node);
				let curLeftBound = leftBound;
				const nodeDiv = document.createElement(node.isLink ? "a" : "div");
				if (node.isLink) nodeDiv.href = node.href;
				nodeDiv.classList.add("node");
				nodeDiv.style.width = nodeRadius * 2 + "px";
				nodeDiv.style.height = nodeRadius * 2 + "px";
				nodeDiv.innerText = node.name;
				const pos = polarToScreen(
					radial / 2 + treeRadius - radiusLeft,
					(leftBound - rightBound) / 2 + rightBound
				);
				moveDiv(nodeDiv, pos.x, pos.y, nodeRadius * 2, nodeRadius * 2);
				// console.log((leftBound - rightBound) / 2 + rightBound, node.name);
				main.appendChild(nodeDiv);
				node.div = nodeDiv;
				node.leftBound = leftBound;
				node.rightBound = rightBound;
				node.innerRadius = treeRadius - radiusLeft;
				node.outerRadius = treeRadius - radiusLeft + radial;
				for (const child of node.children) {
					const rightBound = curLeftBound - angleSpace(child);
					const childPos = drawTree(
						child,
						curLeftBound,
						rightBound,
						radiusLeft - radial
					);
					const edge = drawEdge(pos.x, pos.y, childPos.x, childPos.y);
					nodesToEdge.get(node).set(child, edge);
					nodesToEdge.get(child).set(node, edge);
					curLeftBound = rightBound;
				}

				return pos;
			};

			drawTree(tree, leftTreeBound, rightTreeBound, treeRadius);

			const animateEdge = (anim, direction) => {
				return new Promise(async (res) => {
					anim.animate(
						{ translate: direction ? "0% 0px" : "-100% 0px" },
						{ duration: animationSpeed, fill: "forwards" }
					);
					setTimeout(res, animationSpeed);
				});
			};

			const backup = (from, to) => {
				const path = [from];
				while (from !== to) {
					from = from.parent;
					path.push(from);
					// curNode = from;
				}
				return path;
			};

			const backdown = (from, to) => {
				let path = undefined;
				if (from === to) return [to];
				for (const child of from.children) {
					const ret = backdown(child, to);
					if (ret) {
						path = ret;
						break;
					}
				}
				if (!path) return undefined;
				path.push(from);
				return path;
			};

			const findLCA = (a, b) => {
				while (a !== b) {
					if (a.depth > b.depth) a = a.parent;
					else b = b.parent;
				}
				return a;
			};

			const tracePath = (from, to) => {
				const lca = findLCA(from, to);
				return backup(from, lca)
					.slice(0, -1)
					.concat(backdown(lca, to).reverse());
			};

			let curPath = [];
			let curNode = tree;

			const screenToNode = (x, y) => {
				const style = window.getComputedStyle(main);
				x -= parseFloat(style.left.substring(0, style.left.length - 2));
				y -= parseFloat(style.top.substring(0, style.top.length - 2));
				// cos(a)r = x - main.innerWidth/2;
				// sin(a)r = main.innerHeight - sideMargins - y;
				const angle = Math.atan2(
					main.offsetHeight - sideMargins - y,
					x - main.offsetWidth / 2
				);
				const radius = (x - main.offsetWidth / 2) / Math.cos(angle);
				for (const node of allNodes) {
					if (
						node.leftBound >= angle &&
						node.rightBound <= angle &&
						node.innerRadius <= radius &&
						(node.outerRadius >= radius || node.children.length === 0)
					)
						return node;
				}
			};

			// for (const node of allNodes) {
			// 	node.div.addEventListener("mouseenter", (e) => {
			// 		curPath = tracePath(curNode, node);
			// 	});
			// }

			document.addEventListener("mousemove", (e) => {
				const node = screenToNode(e.clientX, e.clientY);
				if (node) curPath = tracePath(curNode, node);
			});

			tree.div.classList.add("filled");

			setInterval(() => {
				if (curPath.length > 0) {
					while (curPath[0] === curNode) curPath.shift();
					if (curPath.length <= 0) return;
					const prevNode = curNode;
					curNode = curPath.shift();
					const newNode = curNode;
					const filling = curNode.parent === prevNode;
					animateEdge(
						nodesToEdge.get(prevNode).get(curNode).anim,
						filling
					).then(() => {
						if (filling) {
							nodesToEdge
								.get(prevNode)
								.get(newNode)
								.edge.classList.add("filled");
							newNode.div.classList.add("filled");
						} else {
							nodesToEdge
								.get(prevNode)
								.get(newNode)
								.edge.classList.remove("filled");
							prevNode.div.classList.remove("filled");
						}
					});
				}
			}, animationSpeed);

			const moveWidth = main.offsetWidth - window.innerWidth;
			const moveHeight = main.offsetHeight - window.innerHeight;

			main.animate(
				{ left: -0.5 * moveWidth + "px ", top: -0.5 * moveHeight + "px" },
				{ duration: 0, fill: "forwards" }
			);

			document.addEventListener("mousemove", (e) => {
				const px = -e.clientX / window.innerWidth;
				const py = -e.clientY / window.innerHeight;

				main.animate(
					{ left: px * moveWidth + "px ", top: py * moveHeight + "px" },
					{ duration: 2000, fill: "forwards" }
				);
			});
		</script>
	</body>
</html>
